# 组件的使用

## 思考一下我们怎么使用组件

回顾一下我们使用的那些组件库

```bash
npm i element-ui -S
npm i element-plus -S
npm i naive-ui -S
```

都是这样安装，再看看它们是如何使用的

可以看到它们都分别提供了

1. 完整引入
2. 按需引入
3. 手动引入

三种方式。

我们以 `Element Plus` 去分析一下，借以抛砖引玉，反向推导我们应该如何实现组件库

> 当然这里先不提 `shadcn` 那种直接把组件生成在项目里面的方式

## 完整引入

从 `element-plus` 的官方文档中，完整引入的方式是这样的

```js
import { createApp } from 'vue'
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'
import App from './App.vue'

const app = createApp(App)

app.use(ElementPlus)
app.mount('#app')
```

那么反向推导可得，`element-plus` 的默认导出是一个 `vue plugin` 让我们看看这里的实现:

```js
import { makeInstaller } from './make-installer.mjs';
import Components from './component.mjs';
import Plugins from './plugin.mjs';
// makeInstaller 为创建一个 vue 插件
// Components 是所有的组件，Plugins 是内置的所有的 Vue 插件, 帮助注册一些指令和全局的一些 $xxx
var installer = makeInstaller([...Components, ...Plugins]);

export { installer as default };
```

以下是 `makeInstaller` 的实现

```js
import { version } from './version.mjs';
import { INSTALLED_KEY } from './constants/key.mjs';
import { provideGlobalConfig } from './components/config-provider/src/hooks/use-global-config.mjs';

const makeInstaller = (components = []) => {
  const install = (app, options) => {
    // 防止重复注册
    if (app[INSTALLED_KEY])
      return;
    app[INSTALLED_KEY] = true;
    // app 层级全局注册
    components.forEach((c) => app.use(c));
    if (options)
      provideGlobalConfig(options, app, true);
  };
  // 返回的是一个 vue plugin
  return {
    version,
    install
  };
};

export { makeInstaller };
```

所以因为这种全局注册的方式，所以为了智能提示，就需要在 `tsconfig.json` 里面配置

```json
{
  "compilerOptions": {
    // ...
    "types": ["element-plus/global"]
  }
}
```

这是为了主动通知 `vue` `vscode` 插件告诉它全局组件的智能提示。

## 手动引入

Element Plus 提供了基于 ES Module 的开箱即用的 Tree Shaking 功能。

但你需要安装 `unplugin-element-plus` 来导入样式。

```vue
<template>
  <el-button>I am ElButton</el-button>
</template>

<script>
import { ElButton } from 'element-plus'

export default {
  components: { ElButton },
}
</script>
```

我们来分析一下这种场景，已经知道 `css` 和 `js` 是分离的，但是上面代码，明明是引入一个组件，那为什么样式也被引入进来呢

这一切都在于 `unplugin-element-plus` 这个编译插件做个转化:

```js
import { ElButton } from 'element-plus'

//    ↓ ↓ ↓ ↓ ↓ ↓

import { ElButton } from 'element-plus'
import 'element-plus/es/components/button/style/css'
```

> `element-plus/es/components/button/style/css` 和 `element-plus/es/components/button/style/index` 的不同点在于引入的一个是 `css` 一个是 `scss`

本质上这个插件就是先用 `es-module-lexer` 分析一下导入, 然后在最后一个导入下面，插入样式导入语句。

## 自动导入

刚刚介绍了手动引入的编译插件，自动导入方案实际上是另外一种编译方案

我们来看一下它的表象:

```ts
import { defineConfig } from 'vite'
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'

export default defineConfig({
  // ...
  plugins: [
    // ...
    AutoImport({
      resolvers: [ElementPlusResolver()],
    }),
    Components({
      resolvers: [ElementPlusResolver()],
    }),
  ],
})
```

为什么它能做到自动导入呢?

我们分 `2` 个层面去看:

### unplugin-vue-components

### unplugin-auto-import